{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///Users/christianwang/Developer/ucsbhack/SBHACK26/frontend/src/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Google from \"next-auth/providers/google\";\n\nconst BACKEND_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3001\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  providers: [\n    Google({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n    }),\n  ],\n  pages: {\n    signIn: \"/login\",\n  },\n  callbacks: {\n    async signIn({ user, account }) {\n      // Upsert user in backend database when they sign in\n      if (account?.provider === \"google\" && user.email) {\n        try {\n          const response = await fetch(`${BACKEND_URL}/api/users/upsert`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              googleId: account.providerAccountId,\n              email: user.email,\n              name: user.name,\n              image: user.image,\n            }),\n          });\n\n          if (!response.ok) {\n            console.error(\"Failed to upsert user in database\");\n            // Still allow sign in even if backend call fails\n          } else {\n            const data = await response.json();\n            // Store the database UUID in the user object for the JWT callback\n            if (data.user?.id) {\n              (user as any).dbId = data.user.id;\n            }\n          }\n        } catch (error) {\n          console.error(\"Error upserting user:\", error);\n          // Still allow sign in even if backend call fails\n        }\n      }\n      return true;\n    },\n    async jwt({ token, user, account }) {\n      // Persist the OAuth access_token and database user id\n      if (account) {\n        token.accessToken = account.access_token;\n        token.googleId = account.providerAccountId;\n      }\n      if (user) {\n        // Use the database UUID if available, otherwise we'll look it up\n        token.dbId = (user as any).dbId;\n      }\n      \n      // If we don't have a dbId yet but have a googleId, try to fetch it\n      if (!token.dbId && token.googleId) {\n        try {\n          const response = await fetch(\n            `${BACKEND_URL}/api/users/by-google-id/${token.googleId}`\n          );\n          if (response.ok) {\n            const data = await response.json();\n            token.dbId = data.user?.id;\n          }\n        } catch (error) {\n          console.error(\"Error fetching user by google id:\", error);\n        }\n      }\n      \n      return token;\n    },\n    async session({ session, token }) {\n      // Add the database user id to the session\n      if (token.dbId) {\n        session.user.id = token.dbId as string;\n      } else if (token.sub) {\n        // Fallback to Google ID if dbId not available\n        session.user.id = token.sub;\n      }\n      return session;\n    },\n  },\n  session: {\n    strategy: \"jwt\",\n  },\n  secret: process.env.AUTH_SECRET,\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;;;AAEA,MAAM,cAAc,kEAAmC;AAEhD,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,uYAAQ,EAAC;IAC1D,WAAW;QACT,IAAA,8NAAM,EAAC;YACL,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;QAChD;KACD;IACD,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,MAAM,QAAO,EAAE,IAAI,EAAE,OAAO,EAAE;YAC5B,oDAAoD;YACpD,IAAI,SAAS,aAAa,YAAY,KAAK,KAAK,EAAE;gBAChD,IAAI;oBACF,MAAM,WAAW,MAAM,MAAM,GAAG,YAAY,iBAAiB,CAAC,EAAE;wBAC9D,QAAQ;wBACR,SAAS;4BAAE,gBAAgB;wBAAmB;wBAC9C,MAAM,KAAK,SAAS,CAAC;4BACnB,UAAU,QAAQ,iBAAiB;4BACnC,OAAO,KAAK,KAAK;4BACjB,MAAM,KAAK,IAAI;4BACf,OAAO,KAAK,KAAK;wBACnB;oBACF;oBAEA,IAAI,CAAC,SAAS,EAAE,EAAE;wBAChB,QAAQ,KAAK,CAAC;oBACd,iDAAiD;oBACnD,OAAO;wBACL,MAAM,OAAO,MAAM,SAAS,IAAI;wBAChC,kEAAkE;wBAClE,IAAI,KAAK,IAAI,EAAE,IAAI;4BAChB,KAAa,IAAI,GAAG,KAAK,IAAI,CAAC,EAAE;wBACnC;oBACF;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,yBAAyB;gBACvC,iDAAiD;gBACnD;YACF;YACA,OAAO;QACT;QACA,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE;YAChC,sDAAsD;YACtD,IAAI,SAAS;gBACX,MAAM,WAAW,GAAG,QAAQ,YAAY;gBACxC,MAAM,QAAQ,GAAG,QAAQ,iBAAiB;YAC5C;YACA,IAAI,MAAM;gBACR,iEAAiE;gBACjE,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;YACjC;YAEA,mEAAmE;YACnE,IAAI,CAAC,MAAM,IAAI,IAAI,MAAM,QAAQ,EAAE;gBACjC,IAAI;oBACF,MAAM,WAAW,MAAM,MACrB,GAAG,YAAY,wBAAwB,EAAE,MAAM,QAAQ,EAAE;oBAE3D,IAAI,SAAS,EAAE,EAAE;wBACf,MAAM,OAAO,MAAM,SAAS,IAAI;wBAChC,MAAM,IAAI,GAAG,KAAK,IAAI,EAAE;oBAC1B;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,qCAAqC;gBACrD;YACF;YAEA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,0CAA0C;YAC1C,IAAI,MAAM,IAAI,EAAE;gBACd,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,IAAI;YAC9B,OAAO,IAAI,MAAM,GAAG,EAAE;gBACpB,8CAA8C;gBAC9C,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG;YAC7B;YACA,OAAO;QACT;IACF;IACA,SAAS;QACP,UAAU;IACZ;IACA,QAAQ,QAAQ,GAAG,CAAC,WAAW;AACjC"}},
    {"offset": {"line": 162, "column": 0}, "map": {"version":3,"sources":["file:///Users/christianwang/Developer/ucsbhack/SBHACK26/frontend/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { handlers } from \"@/auth\";\n\nexport const { GET, POST } = handlers;\n"],"names":[],"mappings":";;;;;;AAAA;;AAEO,MAAM,EAAE,GAAG,EAAE,IAAI,EAAE,GAAG,yHAAQ"}}]
}