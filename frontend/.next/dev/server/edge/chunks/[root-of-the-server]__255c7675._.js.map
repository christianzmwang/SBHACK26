{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Google from \"next-auth/providers/google\";\n\nconst BACKEND_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3001\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  providers: [\n    Google({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n    }),\n  ],\n  pages: {\n    signIn: \"/login\",\n  },\n  callbacks: {\n    async signIn({ user, account }) {\n      // Upsert user in backend database when they sign in\n      if (account?.provider === \"google\" && user.email) {\n        try {\n          const response = await fetch(`${BACKEND_URL}/api/users/upsert`, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n              googleId: account.providerAccountId,\n              email: user.email,\n              name: user.name,\n              image: user.image,\n            }),\n          });\n\n          if (!response.ok) {\n            console.error(\"Failed to upsert user in database\");\n            // Still allow sign in even if backend call fails\n          } else {\n            const data = await response.json();\n            // Store the database UUID in the user object for the JWT callback\n            if (data.user?.id) {\n              (user as any).dbId = data.user.id;\n            }\n          }\n        } catch (error) {\n          console.error(\"Error upserting user:\", error);\n          // Still allow sign in even if backend call fails\n        }\n      }\n      return true;\n    },\n    async jwt({ token, user, account }) {\n      // Persist the OAuth access_token and database user id\n      if (account) {\n        token.accessToken = account.access_token;\n        token.googleId = account.providerAccountId;\n      }\n      if (user) {\n        // Use the database UUID if available, otherwise we'll look it up\n        token.dbId = (user as any).dbId;\n      }\n      \n      // If we don't have a dbId yet but have a googleId, try to fetch it\n      if (!token.dbId && token.googleId) {\n        try {\n          const response = await fetch(\n            `${BACKEND_URL}/api/users/by-google-id/${token.googleId}`\n          );\n          if (response.ok) {\n            const data = await response.json();\n            token.dbId = data.user?.id;\n          }\n        } catch (error) {\n          console.error(\"Error fetching user by google id:\", error);\n        }\n      }\n      \n      return token;\n    },\n    async session({ session, token }) {\n      // Add the database user id to the session\n      if (token.dbId) {\n        session.user.id = token.dbId as string;\n      } else if (token.sub) {\n        // Fallback to Google ID if dbId not available\n        session.user.id = token.sub;\n      }\n      return session;\n    },\n  },\n  session: {\n    strategy: \"jwt\",\n  },\n  secret: process.env.AUTH_SECRET,\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;;;AAEA,MAAM,cAAc,kEAAmC;AAEhD,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,6YAAQ,EAAC;IAC1D,WAAW;QACT,IAAA,oOAAM,EAAC;YACL,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;QAChD;KACD;IACD,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,MAAM,QAAO,EAAE,IAAI,EAAE,OAAO,EAAE;YAC5B,oDAAoD;YACpD,IAAI,SAAS,aAAa,YAAY,KAAK,KAAK,EAAE;gBAChD,IAAI;oBACF,MAAM,WAAW,MAAM,MAAM,GAAG,YAAY,iBAAiB,CAAC,EAAE;wBAC9D,QAAQ;wBACR,SAAS;4BAAE,gBAAgB;wBAAmB;wBAC9C,MAAM,KAAK,SAAS,CAAC;4BACnB,UAAU,QAAQ,iBAAiB;4BACnC,OAAO,KAAK,KAAK;4BACjB,MAAM,KAAK,IAAI;4BACf,OAAO,KAAK,KAAK;wBACnB;oBACF;oBAEA,IAAI,CAAC,SAAS,EAAE,EAAE;wBAChB,QAAQ,KAAK,CAAC;oBACd,iDAAiD;oBACnD,OAAO;wBACL,MAAM,OAAO,MAAM,SAAS,IAAI;wBAChC,kEAAkE;wBAClE,IAAI,KAAK,IAAI,EAAE,IAAI;4BAChB,KAAa,IAAI,GAAG,KAAK,IAAI,CAAC,EAAE;wBACnC;oBACF;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,yBAAyB;gBACvC,iDAAiD;gBACnD;YACF;YACA,OAAO;QACT;QACA,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE;YAChC,sDAAsD;YACtD,IAAI,SAAS;gBACX,MAAM,WAAW,GAAG,QAAQ,YAAY;gBACxC,MAAM,QAAQ,GAAG,QAAQ,iBAAiB;YAC5C;YACA,IAAI,MAAM;gBACR,iEAAiE;gBACjE,MAAM,IAAI,GAAG,AAAC,KAAa,IAAI;YACjC;YAEA,mEAAmE;YACnE,IAAI,CAAC,MAAM,IAAI,IAAI,MAAM,QAAQ,EAAE;gBACjC,IAAI;oBACF,MAAM,WAAW,MAAM,MACrB,GAAG,YAAY,wBAAwB,EAAE,MAAM,QAAQ,EAAE;oBAE3D,IAAI,SAAS,EAAE,EAAE;wBACf,MAAM,OAAO,MAAM,SAAS,IAAI;wBAChC,MAAM,IAAI,GAAG,KAAK,IAAI,EAAE;oBAC1B;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,qCAAqC;gBACrD;YACF;YAEA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,0CAA0C;YAC1C,IAAI,MAAM,IAAI,EAAE;gBACd,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,IAAI;YAC9B,OAAO,IAAI,MAAM,GAAG,EAAE;gBACpB,8CAA8C;gBAC9C,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,GAAG;YAC7B;YACA,OAAO;QACT;IACF;IACA,SAAS;QACP,UAAU;IACZ;IACA,QAAQ,QAAQ,GAAG,CAAC,WAAW;AACjC"}},
    {"offset": {"line": 120, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { auth } from \"@/auth\";\nimport { NextResponse } from \"next/server\";\n\n// Public routes that don't require authentication\nconst publicRoutes = [\"/login\"];\n\nexport default auth((req) => {\n  const { nextUrl } = req;\n  const isLoggedIn = !!req.auth;\n\n  // Check if the current route is public\n  const isPublicRoute = publicRoutes.some((route) =>\n    nextUrl.pathname.startsWith(route)\n  );\n\n  // Redirect to login if accessing any protected route without authentication\n  if (!isPublicRoute && !isLoggedIn) {\n    const loginUrl = new URL(\"/login\", nextUrl.origin);\n    loginUrl.searchParams.set(\"callbackUrl\", nextUrl.pathname);\n    return NextResponse.redirect(loginUrl);\n  }\n\n  // Redirect to home if accessing login while authenticated\n  if (isPublicRoute && isLoggedIn) {\n    return NextResponse.redirect(new URL(\"/\", nextUrl.origin));\n  }\n\n  return NextResponse.next();\n});\n\nexport const config = {\n  matcher: [\n    // Match all routes except static files and API routes\n    \"/((?!api|_next/static|_next/image|favicon.ico).*)\",\n  ],\n};\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;;;AAEA,kDAAkD;AAClD,MAAM,eAAe;IAAC;CAAS;uCAEhB,IAAA,2HAAI,EAAC,CAAC;IACnB,MAAM,EAAE,OAAO,EAAE,GAAG;IACpB,MAAM,aAAa,CAAC,CAAC,IAAI,IAAI;IAE7B,uCAAuC;IACvC,MAAM,gBAAgB,aAAa,IAAI,CAAC,CAAC,QACvC,QAAQ,QAAQ,CAAC,UAAU,CAAC;IAG9B,4EAA4E;IAC5E,IAAI,CAAC,iBAAiB,CAAC,YAAY;QACjC,MAAM,WAAW,IAAI,IAAI,UAAU,QAAQ,MAAM;QACjD,SAAS,YAAY,CAAC,GAAG,CAAC,eAAe,QAAQ,QAAQ;QACzD,OAAO,iWAAY,CAAC,QAAQ,CAAC;IAC/B;IAEA,0DAA0D;IAC1D,IAAI,iBAAiB,YAAY;QAC/B,OAAO,iWAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,MAAM;IAC1D;IAEA,OAAO,iWAAY,CAAC,IAAI;AAC1B;AAEO,MAAM,SAAS;IACpB,SAAS;QACP,sDAAsD;QACtD;KACD;AACH"}}]
}